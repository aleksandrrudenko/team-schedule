<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Schedule - Workload Balancing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        label {
            font-weight: 500;
            color: #555;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #2980b9;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 13px;
        }

        .schedule-table th {
            background: #34495e;
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .schedule-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
            vertical-align: middle;
        }

        .schedule-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .employee-name {
            font-weight: 600;
            text-align: left;
            padding-left: 12px !important;
            background: #ecf0f1 !important;
            position: sticky;
            left: 0;
            z-index: 5;
            min-width: 150px;
        }

        .timezone {
            font-size: 11px;
            color: #7f8c8d;
            font-weight: normal;
        }

        .cell {
            min-width: 100px;
            height: 70px;
            position: relative;
        }

        .cell.work-hours {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .cell.on-call {
            background: #fff3e0;
            color: #e65100;
            font-weight: 600;
            border: 2px solid #ff9800;
        }

        .cell.weekend {
            background: #f3e5f5;
            color: #6a1b9a;
        }

        .cell.work-hours.on-call {
            background: linear-gradient(135deg, #e8f5e9 50%, #fff3e0 50%);
            border: 2px solid #ff9800;
        }

        .cell.off-hours {
            background: #fafafa;
            color: #999;
        }

        .cell.shift-1 {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid #1976d2;
        }

        .cell.shift-2 {
            background: #fff9c4;
            color: #f57f17;
            border-left: 4px solid #fbc02d;
        }

        .cell.shift-3 {
            background: #fce4ec;
            color: #c2185b;
            border-left: 4px solid #e91e63;
        }

        .cell.shift-1.on-call {
            background: linear-gradient(135deg, #e3f2fd 50%, #fff3e0 50%);
            border: 2px solid #ff9800;
        }

        .cell.shift-2.on-call {
            background: linear-gradient(135deg, #fff9c4 50%, #fff3e0 50%);
            border: 2px solid #ff9800;
        }

        .cell.shift-3.on-call {
            background: linear-gradient(135deg, #fce4ec 50%, #fff3e0 50%);
            border: 2px solid #ff9800;
        }

        .cell.on-call.shift-1,
        .cell.on-call.shift-2,
        .cell.on-call.shift-3 {
            background: linear-gradient(135deg, #fff3e0 50%, #e3f2fd 50%);
            border: 2px solid #ff9800;
        }

        .cell-content {
            font-size: 11px;
            line-height: 1.3;
            font-weight: 500;
        }

        .shift-time {
            font-size: 8px;
            color: #555;
            margin-top: 3px;
            font-weight: normal;
            line-height: 1.2;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 3px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .stat-card h3 {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .stat-detail {
            font-size: 12px;
            color: #95a5a6;
            margin-top: 5px;
        }

        .month-header {
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 8px;
        }

        .timezone-info {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .editable-cell {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .editable-cell:hover {
            opacity: 0.8;
            box-shadow: 0 0 0 2px #3498db;
        }

        .cell-editor-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .cell-editor-modal.show {
            display: flex;
        }

        .cell-editor-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .cell-editor-content h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .cell-option {
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8f9fa;
        }

        .cell-option:hover {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .cell-option.selected {
            background: #d4edda;
            border-color: #28a745;
        }

        .cell-option-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .cell-option-desc {
            font-size: 12px;
            color: #7f8c8d;
        }

        .cell-editor-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .cell-editor-actions button {
            padding: 10px 20px;
        }

        .cell-editor-actions button.cancel {
            background: #95a5a6;
        }

        .cell-editor-actions button.cancel:hover {
            background: #7f8c8d;
        }

        @media print {
            body {
                background: white;
            }
            .controls, .legend {
                display: none;
            }
            .editable-cell {
                cursor: default;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div>
                <h1 style="margin: 0;">üìÖ Team Schedule</h1>
                <p class="subtitle">Three states: On-call (with 1h overlap), Regular work, Day off | Total 165-185 hours/month (HARD RULE) | <a href="SCHEDULE_RULES.md" target="_blank">üìñ Schedule Rules</a></p>
            </div>
            <div id="userInfo" style="text-align: right;">
                <div id="userName" style="font-weight: 600; color: #2c3e50;"></div>
                <div id="userEmail" style="font-size: 12px; color: #7f8c8d;"></div>
                <a href="/logout" style="font-size: 12px; color: #e74c3c; text-decoration: none; margin-top: 5px; display: inline-block;">Logout</a>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthSelect">Month:</label>
                <select id="monthSelect"></select>
            </div>
            <div class="control-group">
                <label for="yearSelect">Year:</label>
                <select id="yearSelect"></select>
            </div>
            <button onclick="generateSchedule()">Update Schedule</button>
            <button onclick="exportToCSV()">Export to CSV</button>
            <button onclick="saveSchedule()" style="background: #27ae60;">üíæ Save Schedule</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #fff3e0; border: 2px solid #ff9800;"></div>
                <span>On-call (with 1h overlap)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #fff3e0 50%, #e3f2fd 50%); border: 2px solid #ff9800;"></div>
                <span>On-call + Regular work (parallel)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e3f2fd; border-left: 4px solid #1976d2;"></div>
                <span>Regular work - Shift 1 (00:00-08:00 CET)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fff9c4; border-left: 4px solid #fbc02d;"></div>
                <span>Regular work - Shift 2 (08:00-16:00 CET)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fce4ec; border-left: 4px solid #e91e63;"></div>
                <span>Regular work - Shift 3 (16:00-00:00 CET)</span>
            </div>
        </div>

        <div id="stats"></div>
        <div id="schedule"></div>
    </div>

    <script>
        // Team configuration
        const team = {
            brazil: [
                { name: 'Brazil 1', timezone: 'America/Sao_Paulo', offset: -3, workStart: 9, workEnd: 18 },
                { name: 'Brazil 2', timezone: 'America/Sao_Paulo', offset: -3, workStart: 9, workEnd: 18 }
            ],
            australia: [
                { name: 'Australia 1', timezone: 'Australia/Sydney', offset: 10, workStart: 9, workEnd: 18 },
                { name: 'Australia 2', timezone: 'Australia/Sydney', offset: 10, workStart: 9, workEnd: 18 }
            ],
            europe: [
                { name: 'Europe 1', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 2', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 3', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 4', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 5', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 6', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 },
                { name: 'Europe 7', timezone: 'Europe/Berlin', offset: 1, workStart: 9, workEnd: 18 }
            ]
        };

        const allEmployees = [...team.brazil, ...team.australia, ...team.europe];
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                           'July', 'August', 'September', 'October', 'November', 'December'];
        const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

        // Shift definitions (time in CET)
        const shifts = [
            { id: 1, name: 'Shift 1', startCET: 0, endCET: 8, label: '00:00-08:00' },   // Night
            { id: 2, name: 'Shift 2', startCET: 8, endCET: 16, label: '08:00-16:00' },  // Day
            { id: 3, name: 'Shift 3', startCET: 16, endCET: 24, label: '16:00-00:00' }  // Evening
        ];

        // Convert time from CET to local time
        function convertCETToLocal(cetHour, employeeOffset) {
            // CET = UTC+1 (winter) or UTC+2 (summer)
            // For simplicity, use UTC+1 as base
            const cetOffset = 1;
            const localHour = (cetHour - cetOffset + employeeOffset + 24) % 24;
            return localHour;
        }

        // Format time
        function formatTime(hour) {
            return String(hour).padStart(2, '0') + ':00';
        }

        // Initialization
        function init() {
            const now = new Date();
            const monthSelect = document.getElementById('monthSelect');
            const yearSelect = document.getElementById('yearSelect');

            // Fill months
            monthNames.forEach((month, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = month;
                if (index === now.getMonth()) option.selected = true;
                monthSelect.appendChild(option);
            });

            // Fill years
            for (let year = now.getFullYear(); year <= now.getFullYear() + 1; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === now.getFullYear()) option.selected = true;
                yearSelect.appendChild(option);
            }

            generateSchedule();
        }

        // Get days of month
        function getDaysInMonth(month, year) {
            const days = [];
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysCount = lastDay.getDate();

            for (let day = 1; day <= daysCount; day++) {
                const date = new Date(year, month, day);
                days.push({
                    date: date,
                    day: day,
                    dayOfWeek: date.getDay(),
                    isWeekend: date.getDay() === 0 || date.getDay() === 6
                });
            }

            return days;
        }

        // Distribute on-call shifts between groups
        // On-call shifts are assigned during each group's working hours (9:00-18:00 local time)
        // Group 1: Brazil, Group 2: Australia, Group 3: Europe
        function distributeOnCall(days) {
            const onCallSchedule = {};
            const groups = [
                { name: 'Brazil', employees: team.brazil, workStart: 9, workEnd: 18 },
                { name: 'Australia', employees: team.australia, workStart: 9, workEnd: 18 },
                { name: 'Europe', employees: team.europe, workStart: 9, workEnd: 18 }
            ];
            
            // Initialize counters
            allEmployees.forEach(emp => {
                onCallSchedule[emp.name] = { count: 0, days: [], shifts: [] };
            });

            // Distribute on-call shifts with 1 hour overlap for handover
            // Australia: CET 00:00-09:00 (9 hours)
            // Europe: CET 08:00-18:00 (10 hours, overlap 08:00-09:00)
            // Brazil: CET 17:00-01:00 (8 hours, overlap 17:00-18:00 and 00:00-01:00)
            const onCallShiftsByGroup = {
                'Australia': { startCET: 0, endCET: 9 },
                'Europe': { startCET: 8, endCET: 18 },
                'Brazil': { startCET: 17, endCET: 1 } // Crosses midnight
            };
            
            days.forEach((dayInfo, dayIndex) => {
                groups.forEach((group, groupIndex) => {
                    // Determine which group works on this day (rotation)
                    const dayGroupIndex = (dayIndex + groupIndex) % groups.length;
                    const workingGroup = groups[dayGroupIndex];
                    
                    // Distribute on-call shift within group between employees
                    const employeeIndexInGroup = Math.floor(dayIndex / groups.length) % workingGroup.employees.length;
                    const employee = workingGroup.employees[employeeIndexInGroup];
                    
                    // Get shift time in CET for this group
                    const shiftTimes = onCallShiftsByGroup[workingGroup.name];
                    const cetStart = shiftTimes.startCET;
                    const cetEnd = shiftTimes.endCET;
                    
                    // Convert to group's local time
                    const cetOffset = 1; // CET = UTC+1
                    const groupOffset = workingGroup.employees[0].offset;
                    
                    // Local start time
                    const localStart = (cetStart - cetOffset + groupOffset + 24) % 24;
                    
                    // Local end time (account for midnight crossover for Brazil)
                    let localEnd;
                    if (cetEnd < cetStart) {
                        // Crosses midnight (Brazil)
                        localEnd = (cetEnd - cetOffset + groupOffset + 24) % 24;
                    } else {
                        localEnd = (cetEnd - cetOffset + groupOffset + 24) % 24;
                    }
                    
                    // Format CET time (account for midnight crossover)
                    let cetLabel;
                    if (cetEnd < cetStart) {
                        cetLabel = `${formatTime(cetStart)}-${formatTime(cetEnd)}+1`; // +1 means next day
                    } else {
                        cetLabel = `${formatTime(cetStart)}-${formatTime(cetEnd)}`;
                    }
                    
                    // Create on-call shift
                    const onCallShift = {
                        id: 'oncall',
                        name: 'On-call',
                        startCET: cetStart,
                        endCET: cetEnd,
                        crossesMidnight: cetEnd < cetStart,
                        startLocal: localStart,
                        endLocal: localEnd,
                        label: cetLabel,
                        labelLocal: `${formatTime(localStart)}-${formatTime(localEnd)}`
                    };
                    
                    onCallSchedule[employee.name].count++;
                    onCallSchedule[employee.name].days.push(dayInfo.day);
                    onCallSchedule[employee.name].shifts.push({
                        day: dayInfo.day,
                        shift: onCallShift
                    });
                });
            });

            return onCallSchedule;
        }

        // Check consecutive work days for an employee (for Europeans: max 5 days)
        function getConsecutiveWorkDays(employee, dayIndex, days, shiftSchedule, onCallSchedule) {
            let consecutive = 0;
            // Count backwards from current day
            for (let i = dayIndex; i >= 0; i--) {
                const dayInfo = days[i];
                const hasShift = !!shiftSchedule[employee.name][dayInfo.day];
                const isOnCall = onCallSchedule[employee.name].days.includes(dayInfo.day);
                if (hasShift || isOnCall) {
                    consecutive++;
                } else {
                    break;
                }
            }
            return consecutive;
        }

        // Check consecutive days off for an employee (for Europeans: max 2 days)
        function getConsecutiveDaysOff(employee, dayIndex, days, shiftSchedule, onCallSchedule) {
            let consecutive = 0;
            // Count backwards from current day
            for (let i = dayIndex; i >= 0; i--) {
                const dayInfo = days[i];
                const hasShift = !!shiftSchedule[employee.name][dayInfo.day];
                const isOnCall = onCallSchedule[employee.name].days.includes(dayInfo.day);
                if (!hasShift && !isOnCall) {
                    consecutive++;
                } else {
                    break;
                }
            }
            return consecutive;
        }

        // Distribute regular work (shifts) between employees
        // HARD RULE: 165-185 hours per month = on-call hours + regular work hours
        // Regular work can be parallel with on-call
        function distributeShifts(days, onCallSchedule) {
            const shiftSchedule = {};
            const minTotalHours = 165; // MINIMUM (hard rule)
            const maxTotalHours = 185; // MAXIMUM
            const targetTotalHours = 180; // Target value
            
            // Initialize
            allEmployees.forEach(emp => {
                shiftSchedule[emp.name] = {};
                days.forEach(dayInfo => {
                    shiftSchedule[emp.name][dayInfo.day] = null;
                });
            });

            // Calculate statistics per employee
            const employeeStats = {};
            allEmployees.forEach(emp => {
                // Calculate on-call hours accounting for midnight crossover
                let onCallHours = 0;
                onCallSchedule[emp.name].shifts.forEach(shiftInfo => {
                    const shift = shiftInfo.shift;
                    if (shift.crossesMidnight) {
                        // Crosses midnight: 17:00-01:00 = 8 hours
                        onCallHours += 8;
                    } else {
                        // Regular shift: calculate difference
                        const hours = shift.endCET - shift.startCET;
                        onCallHours += hours;
                    }
                });
                
                // Check employee group
                const isEuropean = team.europe.some(e => e.name === emp.name);
                const isBrazilian = team.brazil.some(e => e.name === emp.name);
                const isAustralian = team.australia.some(e => e.name === emp.name);
                
                // HARD RULE: minimum 165 hours total (on-call + regular work), maximum 185
                // Calculate how much regular work is needed to reach minimum 165 hours
                const minRegularHours = Math.max(0, minTotalHours - onCallHours); // Minimum regular work to reach 165 hours
                const maxRegularHours = Math.max(0, maxTotalHours - onCallHours); // Maximum regular work
                const targetRegularHours = Math.max(0, targetTotalHours - onCallHours); // Target regular work
                
                // FOR ALL the same: minimum regular work to reach 165 hours total
                // DO NOT set different minimums for different groups
                const finalTargetRegularHours = minRegularHours; // Minimum to reach 165 hours total
                
                const targetRegularShifts = Math.ceil(finalTargetRegularHours / 8); // 8 hours per shift
                
                employeeStats[emp.name] = {
                    shifts: 0,
                    onCallHours: onCallHours,
                    targetRegularShifts: targetRegularShifts,
                    isEuropean: isEuropean,
                    isBrazilian: isBrazilian,
                    isAustralian: isAustralian
                };
            });

            // Create list of all available shifts (all days, all shifts)
            const allShifts = [];
            days.forEach(dayInfo => {
                shifts.forEach(shift => {
                    allShifts.push({ day: dayInfo, shift: shift });
                });
            });

            // Shuffle for more even distribution
            for (let i = allShifts.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allShifts[i], allShifts[j]] = [allShifts[j], allShifts[i]];
            }

            // Distribute shifts - HARD RULE: minimum 165 hours for ALL
            // Pass multiple times to guarantee minimum
            for (let pass = 0; pass < 3; pass++) {
                // Shuffle again for each pass
                for (let i = allShifts.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allShifts[i], allShifts[j]] = [allShifts[j], allShifts[i]];
                }
            // Regular work can be parallel with on-call
            // Priority to those not on-call this day (to reduce days off)
            allShifts.forEach(({ day, shift }) => {
                // Find day index
                const dayIndex = days.findIndex(d => d.day === day.day);
                
                // Find employee who:
                // 1. Has not reached 180 hours yet (continue assigning even after target)
                // 2. Priority to those with fewer hours
                // 3. HUGE priority to those NOT on-call this day (to reduce days off)
                // 4. Regular work can be parallel with on-call
                // 5. For Europeans: avoid more than 5 consecutive work days or 2 consecutive days off
                
                let bestEmployee = null;
                let bestScore = -1;
                
                allEmployees.forEach((emp, empIndex) => {
                    const isOnCall = onCallSchedule[emp.name].days.includes(day.day);
                    
                    const currentShifts = employeeStats[emp.name].shifts;
                    const onCallHours = employeeStats[emp.name].onCallHours;
                    const currentRegularHours = currentShifts * 8;
                    const totalHours = onCallHours + currentRegularHours;
                    const targetShifts = employeeStats[emp.name].targetRegularShifts;
                    const isEuropean = employeeStats[emp.name].isEuropean;
                    const isBrazilian = employeeStats[emp.name].isBrazilian;
                    const isAustralian = employeeStats[emp.name].isAustralian;
                    
                    // HARD RULE: minimum 165 hours, maximum 185 hours
                    const hoursNeeded = minTotalHours - totalHours; // How much needed to reach minimum
                    const hoursOverMax = totalHours - maxTotalHours; // Over maximum
                    
                    // If exceeded maximum, skip
                    if (hoursOverMax > 0) {
                        return;
                    }
                    
                    // For Europeans: check consecutive days (soft rule)
                    if (isEuropean && dayIndex >= 0) {
                        const consecutiveWorkDays = getConsecutiveWorkDays(emp, dayIndex - 1, days, shiftSchedule, onCallSchedule);
                        const consecutiveDaysOff = getConsecutiveDaysOff(emp, dayIndex - 1, days, shiftSchedule, onCallSchedule);
                        
                        // If already has 5+ consecutive work days, penalize adding another
                        if (consecutiveWorkDays >= 5) {
                            // Skip if not critical (below minimum)
                            const isBelowMinimum = totalHours < minTotalHours;
                            if (!isBelowMinimum) {
                                return; // Skip this employee for this shift
                            }
                        }
                        
                        // If already has 2+ consecutive days off, prefer not to add another day off
                        // (but this is handled by the fact that we're assigning a shift, so it won't be a day off)
                        // However, if we're trying to assign and they have 2+ days off, give bonus
                        if (consecutiveDaysOff >= 2) {
                            // This is good - they need work, so we'll add bonus below
                        }
                    }
                    
                    // If reached minimum (165) but not maximum (185), continue with lower priority
                    // If below minimum - HUGE priority
                    const isBelowMinimum = totalHours < minTotalHours;
                    const isBelowTarget = totalHours < targetTotalHours;
                    
                    // Scoring: priority to those with fewer hours, work days
                    // HUGE priority to those NOT on-call (to reduce days off)
                    let score = 0;
                    
                    if (isBelowMinimum) {
                        // CRITICAL priority - below minimum!
                        score = (minTotalHours - totalHours) * 1000 + // HUGE weight for those below minimum
                                (targetShifts - currentShifts) * 50 +
                                (day.isWeekend ? 0 : 10);
                    } else if (isBelowTarget) {
                        // High priority - below target value
                        score = (targetTotalHours - totalHours) * 30 +
                                (targetShifts - currentShifts) * 20 +
                                (day.isWeekend ? 0 : 5);
                    } else {
                        // Low priority - already reached target, but can add up to maximum
                        score = (maxTotalHours - totalHours) * 5 +
                                (day.isWeekend ? 0 : 2);
                    }
                    
                    // HUGE bonus for those NOT on-call this day
                    if (!isOnCall) {
                        score += 200; // Very large bonus to fill days without on-call
                    }
                    
                    // Group bonuses
                    if (isEuropean) {
                        score += 25; // Large bonus for Europeans
                        
                        // Bonus for Europeans with consecutive days off (to break the streak)
                        if (dayIndex >= 0) {
                            const consecutiveDaysOff = getConsecutiveDaysOff(emp, dayIndex - 1, days, shiftSchedule, onCallSchedule);
                            if (consecutiveDaysOff >= 2) {
                                score += 50; // Bonus to break consecutive days off
                            }
                        }
                        
                        // Penalty for Europeans with too many consecutive work days (soft rule)
                        if (dayIndex >= 0) {
                            const consecutiveWorkDays = getConsecutiveWorkDays(emp, dayIndex - 1, days, shiftSchedule, onCallSchedule);
                            if (consecutiveWorkDays >= 4) {
                                score -= 30; // Penalty if already has 4+ consecutive work days
                            }
                        }
                    } else if (isBrazilian || isAustralian) {
                        score += 15; // Bonus for Brazilians and Australians
                    }
                    
                    score += (Math.random() * 2); // Small randomness for variety
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestEmployee = emp;
                    }
                });
                
                // Assign shift to best candidate
                // IMPORTANT: if employee is below minimum 165 hours, assign shift even if already has shift this day
                // (this can be parallel with on-call or replace existing shift)
                if (bestEmployee) {
                    const empTotalHours = employeeStats[bestEmployee.name].onCallHours + 
                                         employeeStats[bestEmployee.name].shifts * 8;
                    const isBelowMinimum = empTotalHours < minTotalHours;
                    const hadShift = !!shiftSchedule[bestEmployee.name][day.day];
                    
                    // If below minimum - assign shift in any case (may replace existing)
                    if (isBelowMinimum || !hadShift) {
                        shiftSchedule[bestEmployee.name][day.day] = shift;
                        // Update counter only if this is a new shift
                        if (!hadShift) {
                            employeeStats[bestEmployee.name].shifts++;
                        }
                    }
                }
            });
            } // End of passes loop

            // Remove one regular work shift from each employee to get closer to ~180 hours
            // This is done after ensuring minimum 165 hours is met
            allEmployees.forEach(emp => {
                const onCallHours = employeeStats[emp.name].onCallHours;
                const currentShifts = employeeStats[emp.name].shifts;
                const currentRegularHours = currentShifts * 8;
                const totalHours = onCallHours + currentRegularHours;
                const isEuropean = employeeStats[emp.name].isEuropean;
                
                // Only remove a shift if:
                // 1. Employee has at least one shift
                // 2. After removal, they will still have >= 165 hours
                if (currentShifts > 0 && (totalHours - 8) >= minTotalHours) {
                    // Find a day with a regular work shift (prefer non-on-call days, then weekends)
                    // For Europeans: prefer removing from days that would break long consecutive work streaks
                    const daysWithShifts = [];
                    days.forEach((dayInfo, dayIndex) => {
                        const hasShift = !!shiftSchedule[emp.name][dayInfo.day];
                        const isOnCall = onCallSchedule[emp.name].days.includes(dayInfo.day);
                        if (hasShift) {
                            // For Europeans: check if removing this shift would help break consecutive work days
                            let consecutiveWorkDays = 0;
                            if (isEuropean) {
                                consecutiveWorkDays = getConsecutiveWorkDays(emp, dayIndex, days, shiftSchedule, onCallSchedule);
                            }
                            
                            daysWithShifts.push({
                                day: dayInfo.day,
                                dayInfo: dayInfo,
                                dayIndex: dayIndex,
                                isOnCall: isOnCall,
                                isWeekend: dayInfo.isWeekend,
                                consecutiveWorkDays: consecutiveWorkDays
                            });
                        }
                    });
                    
                    // Prefer removing from:
                    // 1. Days that are part of long consecutive work streaks (for Europeans: 5+ days)
                    // 2. Non-on-call days
                    // 3. Weekends
                    daysWithShifts.sort((a, b) => {
                        if (isEuropean) {
                            // For Europeans: prioritize removing from long consecutive work streaks
                            if (a.consecutiveWorkDays >= 5 && b.consecutiveWorkDays < 5) return -1;
                            if (a.consecutiveWorkDays < 5 && b.consecutiveWorkDays >= 5) return 1;
                        }
                        if (a.isOnCall !== b.isOnCall) return a.isOnCall ? 1 : -1;
                        if (a.isWeekend !== b.isWeekend) return a.isWeekend ? 1 : -1;
                        return 0;
                    });
                    
                    // Remove the first shift (prefer breaking long streaks, then non-on-call, then non-weekend)
                    if (daysWithShifts.length > 0) {
                        const dayToRemove = daysWithShifts[0].day;
                        shiftSchedule[emp.name][dayToRemove] = null;
                        employeeStats[emp.name].shifts--;
                    }
                }
            });

            return shiftSchedule;
        }

        // Determine cell status
        // Three states: On-call, Regular work, Day off
        // Regular work can be parallel with on-call
        function getCellStatus(employee, dayInfo, onCallSchedule, shiftSchedule) {
            const isOnCall = onCallSchedule[employee.name].days.includes(dayInfo.day);
            const shift = shiftSchedule[employee.name][dayInfo.day];
            
            // Get on-call shift information if exists
            const onCallShift = onCallSchedule[employee.name].shifts.find(s => s.day === dayInfo.day);
            
            // Combinations: On-call + Regular work, only On-call, only Regular work, or Day off
            if (isOnCall && onCallShift && shift) {
                // On-call + Regular work (parallel)
                const onCallTime = `On-call: ${onCallShift.shift.label}`;
                const localStart = convertCETToLocal(shift.startCET, employee.offset);
                const localEnd = convertCETToLocal(shift.endCET, employee.offset);
                const regularTime = `Regular: ${shift.label} | Local: ${formatTime(localStart)}-${formatTime(localEnd)}`;
                return { 
                    class: 'on-call shift-2', // Combination of classes
                    text: 'On-call\n+ Regular',
                    timeText: `${onCallTime}\n${regularTime}`
                };
            } else if (isOnCall && onCallShift) {
                // Only On-call
                const shift = onCallShift.shift;
                const timeText = `CET: ${shift.label} | Local: ${shift.labelLocal}`;
                return { 
                    class: 'on-call', 
                    text: 'On-call',
                    timeText: timeText
                };
            } else if (shift) {
                // Only Regular work
                const localStart = convertCETToLocal(shift.startCET, employee.offset);
                const localEnd = convertCETToLocal(shift.endCET, employee.offset);
                const timeText = `CET: ${shift.label} | Local: ${formatTime(localStart)}-${formatTime(localEnd)}`;
                return { 
                    class: `shift-${shift.id}`, 
                    text: 'Regular work',
                    timeText: timeText
                };
            } else {
                // Day off (no on-call, no regular work)
                return { class: 'weekend', text: 'Day off' };
            }
        }

        // Global variables to store schedule data for editing
        let globalOnCallSchedule = null;
        let globalShiftSchedule = null;
        let globalDays = null;

        // Schedule generation
        function generateSchedule() {
            const month = parseInt(document.getElementById('monthSelect').value);
            const year = parseInt(document.getElementById('yearSelect').value);
            const days = getDaysInMonth(month, year);
            const onCallSchedule = distributeOnCall(days);
            const shiftSchedule = distributeShifts(days, onCallSchedule);

            // Store globally for editing
            globalOnCallSchedule = onCallSchedule;
            globalShiftSchedule = shiftSchedule;
            globalDays = days;

            // Statistics
            const stats = calculateStats(onCallSchedule, days, shiftSchedule);
            displayStats(stats);

            // Create table
            const scheduleDiv = document.getElementById('schedule');
            scheduleDiv.innerHTML = '';

            const monthHeader = document.createElement('div');
            monthHeader.className = 'month-header';
            monthHeader.textContent = `${monthNames[month]} ${year}`;
            scheduleDiv.appendChild(monthHeader);

            const table = document.createElement('table');
            table.className = 'schedule-table';

            // Header with dates
            const headerRow = document.createElement('tr');
            const emptyHeader = document.createElement('th');
            emptyHeader.className = 'employee-name';
            emptyHeader.textContent = 'Employee';
            headerRow.appendChild(emptyHeader);

            days.forEach(dayInfo => {
                const th = document.createElement('th');
                th.innerHTML = `${dayInfo.day}<br><span style="font-size: 10px; font-weight: normal;">${dayNames[dayInfo.dayOfWeek === 0 ? 6 : dayInfo.dayOfWeek - 1]}</span>`;
                if (dayInfo.isWeekend) {
                    th.style.background = '#e1bee7';
                }
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            // Rows for each employee
            allEmployees.forEach(employee => {
                const row = document.createElement('tr');
                
                // Employee name
                const nameCell = document.createElement('td');
                nameCell.className = 'employee-name';
                nameCell.innerHTML = `${employee.name}<br><span class="timezone">${employee.timezone}</span>`;
                row.appendChild(nameCell);

                // Cells for each day
                days.forEach(dayInfo => {
                    const cell = document.createElement('td');
                    const status = getCellStatus(employee, dayInfo, onCallSchedule, shiftSchedule);
                    cell.className = `cell ${status.class} editable-cell`;
                    cell.dataset.employee = employee.name;
                    cell.dataset.day = dayInfo.day;
                    let content = `<div class="cell-content">${status.text}</div>`;
                    if (status.timeText) {
                        content += `<div class="shift-time">${status.timeText}</div>`;
                    }
                    cell.innerHTML = content;
                    cell.style.cursor = 'pointer';
                    cell.title = 'Click to edit';
                    cell.addEventListener('click', () => showCellEditor(employee, dayInfo, cell));
                    row.appendChild(cell);
                });

                table.appendChild(row);
            });

            scheduleDiv.appendChild(table);
        }

        // Statistics calculation
        function calculateStats(onCallSchedule, days, shiftSchedule) {
            const stats = {
                totalDays: days.length,
                weekendDays: days.filter(d => d.isWeekend).length,
                workDays: days.filter(d => !d.isWeekend).length,
                employees: []
            };

            allEmployees.forEach(emp => {
                const onCallCount = onCallSchedule[emp.name].count;
                // Calculate on-call hours accounting for midnight crossover
                let onCallHours = 0;
                onCallSchedule[emp.name].shifts.forEach(shiftInfo => {
                    const shift = shiftInfo.shift;
                    if (shift.crossesMidnight) {
                        // Crosses midnight: 17:00-01:00 = 8 hours
                        onCallHours += 8;
                    } else {
                        // Regular shift: calculate difference
                        const hours = shift.endCET - shift.startCET;
                        onCallHours += hours;
                    }
                });
                
                // Calculate regular work (shifts)
                let shiftCount = 0;
                let shift1Count = 0, shift2Count = 0, shift3Count = 0;
                days.forEach(dayInfo => {
                    const shift = shiftSchedule[emp.name][dayInfo.day];
                    if (shift) {
                        shiftCount++;
                        if (shift.id === 1) shift1Count++;
                        else if (shift.id === 2) shift2Count++;
                        else if (shift.id === 3) shift3Count++;
                    }
                });

                const shiftHours = shiftCount * 8; // 8 hours per shift
                const totalHours = shiftHours + onCallHours; // Total workload

                stats.employees.push({
                    name: emp.name,
                    onCallShifts: onCallCount,
                    onCallHours: onCallHours,
                    shifts: shiftCount,
                    shift1: shift1Count,
                    shift2: shift2Count,
                    shift3: shift3Count,
                    shiftHours: shiftHours,
                    totalHours: totalHours
                });
            });

            return stats;
        }

        // Display statistics
        function displayStats(stats) {
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = '';

            const statsContainer = document.createElement('div');
            statsContainer.className = 'stats';

            // Overall statistics
            const totalStat = document.createElement('div');
            totalStat.className = 'stat-card';
            totalStat.innerHTML = `
                <h3>Month</h3>
                <div class="stat-value">${stats.totalDays} days</div>
                <div class="stat-detail">${stats.workDays} work days, ${stats.weekendDays} weekends</div>
            `;
            statsContainer.appendChild(totalStat);

            // Employee statistics
            stats.employees.forEach(emp => {
                const empStat = document.createElement('div');
                empStat.className = 'stat-card';
                const shiftDetail = emp.shifts > 0 ? 
                    `Regular work: ${emp.shifts} shifts (${emp.shift1}/${emp.shift2}/${emp.shift3}) = ${emp.shiftHours}h` : 
                    'No regular work';
                const minHours = 165;
                const maxHours = 185;
                let progress;
                if (emp.totalHours < minHours) {
                    progress = '‚ùå'; // Below minimum - CRITICAL
                } else if (emp.totalHours > maxHours) {
                    progress = '‚ö†Ô∏è'; // Exceeded maximum
                } else {
                    progress = '‚úÖ'; // Within acceptable range
                }
                empStat.innerHTML = `
                    <h3>${emp.name}</h3>
                    <div class="stat-value">${emp.totalHours}h total ${progress}</div>
                    <div class="stat-detail">On-call: ${emp.onCallShifts} shifts = ${emp.onCallHours}h<br>${shiftDetail}<br>Total: ${emp.totalHours}h (range: ${minHours}-${maxHours}h)</div>
                `;
                statsContainer.appendChild(empStat);
            });

            statsDiv.appendChild(statsContainer);
        }

        // Save schedule to server
        async function saveSchedule() {
            if (!globalOnCallSchedule || !globalShiftSchedule || !globalDays) {
                alert('Please generate a schedule first!');
                return;
            }

            const saveButton = document.querySelector('button[onclick="saveSchedule()"]');
            const originalText = saveButton.textContent;
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            try {
                const scheduleData = {
                    onCallSchedule: globalOnCallSchedule,
                    shiftSchedule: globalShiftSchedule,
                    days: globalDays,
                    month: parseInt(document.getElementById('monthSelect').value),
                    year: parseInt(document.getElementById('yearSelect').value),
                    timestamp: new Date().toISOString()
                };

                const response = await fetch('/api/save-schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(scheduleData)
                });

                if (response.ok) {
                    const result = await response.json();
                    alert('‚úÖ Schedule saved successfully!');
                    saveButton.textContent = 'üíæ Saved!';
                    setTimeout(() => {
                        saveButton.textContent = originalText;
                    }, 2000);
                    
                    // Update last saved info from server response
                    if (result.savedBy || result.savedAt) {
                        showLastSavedInfo();
                        updateLastSavedInfo(result.savedBy || result.savedByName, result.savedAt);
                    }
                } else {
                    const error = await response.json();
                    alert('‚ùå Error saving schedule: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error saving schedule:', error);
                alert('‚ùå Error saving schedule: ' + error.message);
            } finally {
                saveButton.disabled = false;
                if (saveButton.textContent === 'Saving...') {
                    saveButton.textContent = originalText;
                }
            }
        }

        // Update last saved info display
        function updateLastSavedInfo(savedBy, savedAt) {
            if (savedBy) {
                document.getElementById('lastSavedBy').textContent = savedBy;
            }
            if (savedAt) {
                const date = new Date(savedAt);
                const dateStr = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                document.getElementById('lastSavedAt').textContent = dateStr;
            }
        }

        // Load saved schedule from server
        async function loadSavedSchedule() {
            try {
                const response = await fetch('/api/load-schedule');
                if (response.ok) {
                    const data = await response.json();
                    if (data.onCallSchedule && data.shiftSchedule && data.days) {
                        globalOnCallSchedule = data.onCallSchedule;
                        globalShiftSchedule = data.shiftSchedule;
                        globalDays = data.days;
                        
                        // Set month and year selectors
                        if (data.month) {
                            document.getElementById('monthSelect').value = data.month;
                        }
                        if (data.year) {
                            document.getElementById('yearSelect').value = data.year;
                        }
                        
                    // Update last saved info
                    if (data.savedBy || data.savedAt) {
                        showLastSavedInfo();
                        updateLastSavedInfo(data.savedBy || data.savedByName, data.savedAt);
                    }
                        
                        // Refresh display
                        const stats = calculateStats(globalOnCallSchedule, globalDays, globalShiftSchedule);
                        displayStats(stats);
                        refreshSchedule();
                        
                        console.log('‚úÖ Loaded saved schedule');
                    }
                } else {
                    // No saved schedule - hide last saved info
                    document.getElementById('lastSavedInfo').style.display = 'none';
                }
            } catch (error) {
                console.log('No saved schedule found or error loading:', error);
                document.getElementById('lastSavedInfo').style.display = 'none';
            }
        }

        // Export to CSV
        function exportToCSV() {
            const month = parseInt(document.getElementById('monthSelect').value);
            const year = parseInt(document.getElementById('yearSelect').value);
            const days = globalDays || getDaysInMonth(month, year);
            // Use global schedules if available (after editing), otherwise generate new
            const onCallSchedule = globalOnCallSchedule || distributeOnCall(days);
            const shiftSchedule = globalShiftSchedule || distributeShifts(days, onCallSchedule);

            let csv = 'Employee,Timezone,Day,Date,Day of week,Type,Shift,CET time,Local time,On-call,Shift hours,On-call hours\n';

            allEmployees.forEach(emp => {
                days.forEach(dayInfo => {
                    const isOnCall = onCallSchedule[emp.name].days.includes(dayInfo.day);
                    const onCallShift = onCallSchedule[emp.name].shifts.find(s => s.day === dayInfo.day);
                    const regularShift = shiftSchedule[emp.name][dayInfo.day];
                    
                    const dateStr = `${String(dayInfo.day).padStart(2, '0')}.${String(month + 1).padStart(2, '0')}.${year}`;
                    const dayName = dayNames[dayInfo.dayOfWeek === 0 ? 6 : dayInfo.dayOfWeek - 1];
                    
                    // Determine day type: On-call, Regular work, or Day off
                    let dayType = 'Day off';
                    let shiftName = 'None';
                    let timeCET = '';
                    let timeLocal = '';
                    let shiftHours = '0';
                    let onCallHours = '0';
                    
                    if (isOnCall && onCallShift) {
                        // On-call
                        dayType = 'On-call';
                        shiftName = 'On-call';
                        timeCET = onCallShift.shift.label;
                        timeLocal = onCallShift.shift.labelLocal;
                        // Calculate on-call hours
                        if (onCallShift.shift.crossesMidnight) {
                            onCallHours = '8'; // 17:00-01:00 = 8 hours
                        } else {
                            onCallHours = String(onCallShift.shift.endCET - onCallShift.shift.startCET);
                        }
                    } else if (regularShift) {
                        // Regular work
                        dayType = 'Regular work';
                        shiftName = regularShift.name;
                        timeCET = regularShift.label;
                        const localStart = convertCETToLocal(regularShift.startCET, emp.offset);
                        const localEnd = convertCETToLocal(regularShift.endCET, emp.offset);
                        timeLocal = `${formatTime(localStart)}-${formatTime(localEnd)}`;
                        shiftHours = '8';
                    }

                    csv += `${emp.name},${emp.timezone},${dayInfo.day},${dateStr},${dayName},${dayType},${shiftName},${timeCET},${timeLocal},${isOnCall ? 'Yes' : 'No'},${shiftHours},${onCallHours}\n`;
                });
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `schedule_${month + 1}_${year}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Get on-call shift for employee group on a specific day
        function getOnCallShiftForEmployee(employee, dayInfo) {
            // Determine which group the employee belongs to
            let groupName = null;
            if (team.brazil.some(e => e.name === employee.name)) {
                groupName = 'Brazil';
            } else if (team.australia.some(e => e.name === employee.name)) {
                groupName = 'Australia';
            } else if (team.europe.some(e => e.name === employee.name)) {
                groupName = 'Europe';
            }

            if (!groupName) return null;

            const onCallShiftsByGroup = {
                'Australia': { startCET: 0, endCET: 9 },
                'Europe': { startCET: 8, endCET: 18 },
                'Brazil': { startCET: 17, endCET: 1 }
            };

            const shiftTimes = onCallShiftsByGroup[groupName];
            const cetStart = shiftTimes.startCET;
            const cetEnd = shiftTimes.endCET;
            const cetOffset = 1;
            const groupOffset = employee.offset;

            const localStart = (cetStart - cetOffset + groupOffset + 24) % 24;
            let localEnd;
            if (cetEnd < cetStart) {
                localEnd = (cetEnd - cetOffset + groupOffset + 24) % 24;
            } else {
                localEnd = (cetEnd - cetOffset + groupOffset + 24) % 24;
            }

            let cetLabel;
            if (cetEnd < cetStart) {
                cetLabel = `${formatTime(cetStart)}-${formatTime(cetEnd)}+1`;
            } else {
                cetLabel = `${formatTime(cetStart)}-${formatTime(cetEnd)}`;
            }

            return {
                id: 'oncall',
                name: 'On-call',
                startCET: cetStart,
                endCET: cetEnd,
                crossesMidnight: cetEnd < cetStart,
                startLocal: localStart,
                endLocal: localEnd,
                label: cetLabel,
                labelLocal: `${formatTime(localStart)}-${formatTime(localEnd)}`
            };
        }

        // Show cell editor modal
        function showCellEditor(employee, dayInfo, cellElement) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('cellEditorModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'cellEditorModal';
                modal.className = 'cell-editor-modal';
                document.body.appendChild(modal);
            }

            const currentStatus = getCellStatus(employee, dayInfo, globalOnCallSchedule, globalShiftSchedule);
            const isOnCall = globalOnCallSchedule[employee.name].days.includes(dayInfo.day);
            const hasShift = !!globalShiftSchedule[employee.name][dayInfo.day];

            // Determine current selection
            let currentSelection = 'day-off';
            if (isOnCall && hasShift) {
                currentSelection = 'on-call-regular';
            } else if (isOnCall) {
                currentSelection = 'on-call';
            } else if (hasShift) {
                const shift = globalShiftSchedule[employee.name][dayInfo.day];
                currentSelection = `shift-${shift.id}`;
            }

            // Build options
            const options = [
                {
                    id: 'on-call',
                    title: 'On-call (with 1h overlap)',
                    desc: '24/7 availability during assigned shift hours'
                },
                {
                    id: 'on-call-regular',
                    title: 'On-call + Regular work (parallel)',
                    desc: 'Both on-call and regular work on the same day'
                },
                {
                    id: 'shift-1',
                    title: 'Regular work - Shift 1 (00:00-08:00 CET)',
                    desc: 'Night shift'
                },
                {
                    id: 'shift-2',
                    title: 'Regular work - Shift 2 (08:00-16:00 CET)',
                    desc: 'Day shift'
                },
                {
                    id: 'shift-3',
                    title: 'Regular work - Shift 3 (16:00-00:00 CET)',
                    desc: 'Evening shift'
                },
                {
                    id: 'day-off',
                    title: 'Day off',
                    desc: 'No work assigned'
                }
            ];

            modal.innerHTML = `
                <div class="cell-editor-content">
                    <h3>Edit Schedule: ${employee.name} - Day ${dayInfo.day}</h3>
                    ${options.map(opt => `
                        <div class="cell-option ${opt.id === currentSelection ? 'selected' : ''}" 
                             data-option="${opt.id}">
                            <div class="cell-option-title">${opt.title}</div>
                            <div class="cell-option-desc">${opt.desc}</div>
                        </div>
                    `).join('')}
                    <div class="cell-editor-actions">
                        <button class="cancel" onclick="closeCellEditor()">Cancel</button>
                        <button onclick="applyCellEdit('${employee.name}', ${dayInfo.day}, '${dayInfo.dayOfWeek}', ${dayInfo.isWeekend})">Apply</button>
                    </div>
                </div>
            `;

            // Add click handlers
            modal.querySelectorAll('.cell-option').forEach(option => {
                option.addEventListener('click', function() {
                    modal.querySelectorAll('.cell-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    modal.dataset.selectedOption = this.dataset.option;
                });
            });

            // Store initial selection
            modal.dataset.selectedOption = currentSelection;
            modal.dataset.employee = employee.name;
            modal.dataset.day = dayInfo.day;

            modal.classList.add('show');

            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeCellEditor();
                }
            });
        }

        // Close cell editor
        function closeCellEditor() {
            const modal = document.getElementById('cellEditorModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Apply cell edit
        function applyCellEdit(employeeName, day, dayOfWeek, isWeekend) {
            const modal = document.getElementById('cellEditorModal');
            if (!modal) return;

            const selectedOption = modal.dataset.selectedOption || modal.querySelector('.cell-option.selected')?.dataset.option;
            if (!selectedOption) return;

            const employee = allEmployees.find(e => e.name === employeeName);
            if (!employee) return;

            const dayInfo = globalDays.find(d => d.day === day);
            if (!dayInfo) return;

            // Update onCallSchedule
            const onCallIndex = globalOnCallSchedule[employeeName].days.indexOf(day);
            if (selectedOption === 'on-call' || selectedOption === 'on-call-regular') {
                // Add on-call if not present
                if (onCallIndex === -1) {
                    const onCallShift = getOnCallShiftForEmployee(employee, dayInfo);
                    if (onCallShift) {
                        globalOnCallSchedule[employeeName].days.push(day);
                        globalOnCallSchedule[employeeName].shifts.push({
                            day: day,
                            shift: onCallShift
                        });
                        globalOnCallSchedule[employeeName].count++;
                    }
                }
            } else {
                // Remove on-call
                if (onCallIndex !== -1) {
                    globalOnCallSchedule[employeeName].days.splice(onCallIndex, 1);
                    globalOnCallSchedule[employeeName].shifts = globalOnCallSchedule[employeeName].shifts.filter(s => s.day !== day);
                    globalOnCallSchedule[employeeName].count--;
                }
            }

            // Update shiftSchedule
            if (selectedOption.startsWith('shift-')) {
                const shiftId = parseInt(selectedOption.split('-')[1]);
                const shift = shifts.find(s => s.id === shiftId);
                if (shift) {
                    globalShiftSchedule[employeeName][day] = shift;
                }
            } else if (selectedOption === 'on-call' || selectedOption === 'day-off') {
                // Remove regular work shift
                globalShiftSchedule[employeeName][day] = null;
            }
            // For 'on-call-regular', keep existing shift or assign default shift 2
            else if (selectedOption === 'on-call-regular') {
                if (!globalShiftSchedule[employeeName][day]) {
                    globalShiftSchedule[employeeName][day] = shifts[1]; // Default to Shift 2
                }
            }

            closeCellEditor();
            refreshSchedule();
        }

        // Refresh schedule display after editing
        function refreshSchedule() {
            if (!globalOnCallSchedule || !globalShiftSchedule || !globalDays) return;

            // Recalculate statistics
            const stats = calculateStats(globalOnCallSchedule, globalDays, globalShiftSchedule);
            displayStats(stats);

            // Update all cells
            document.querySelectorAll('.editable-cell').forEach(cell => {
                const employeeName = cell.dataset.employee;
                const day = parseInt(cell.dataset.day);
                const employee = allEmployees.find(e => e.name === employeeName);
                const dayInfo = globalDays.find(d => d.day === day);

                if (employee && dayInfo) {
                    const status = getCellStatus(employee, dayInfo, globalOnCallSchedule, globalShiftSchedule);
                    cell.className = `cell ${status.class} editable-cell`;
                    let content = `<div class="cell-content">${status.text}</div>`;
                    if (status.timeText) {
                        content += `<div class="shift-time">${status.timeText}</div>`;
                    }
                    cell.innerHTML = content;
                }
            });
        }

        // Load user info if authenticated
        async function loadUserInfo() {
            try {
                const response = await fetch('/api/user');
                if (response.ok) {
                    const user = await response.json();
                    document.getElementById('userName').textContent = user.name || 'User';
                    document.getElementById('userEmail').textContent = user.email || '';
                } else {
                    // Not authenticated, hide user info
                    document.getElementById('userInfo').style.display = 'none';
                }
            } catch (error) {
                // Not running on server or not authenticated
                document.getElementById('userInfo').style.display = 'none';
            }
        }

        // Show last saved info section
        function showLastSavedInfo() {
            document.getElementById('lastSavedInfo').style.display = 'block';
        }

        // Run on load
        init();
        loadUserInfo();
        loadSavedSchedule();
    </script>
</body>
</html>